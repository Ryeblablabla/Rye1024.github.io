<!DOCTYPE html>


<html lang="en">


<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     STILL LIVING
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
  
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

  
  

  

<link rel="alternate" href="/atom.xml" title="STILL LIVING" type="application/atom+xml">
</head>

</html>

<body>
  <div id="app">
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/Shen-Yu/hexo-theme-ayer"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/MYTITLE1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">STILL LIVING</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>

<div id="main">
  <section class="outer">
  <article class="articles">
    
    
    
    
    <article id="post-23岁杂感" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/02/06/23%E5%B2%81%E6%9D%82%E6%84%9F/"
    >23岁杂感</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2023/02/06/23%E5%B2%81%E6%9D%82%E6%84%9F/" class="article-date">
  <time datetime="2023-02-06T15:54:04.000Z" itemprop="datePublished">2023-02-06</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%88%91%E4%BB%AC%E7%9A%84%E6%80%9D%E5%BF%B5/">我们的思念</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <p>今年我二十三岁，读大四。</p>
<p>我在上海租一间十平左右的房子，月租2800，朝南，有床，桌子，空调，卫生间，衣柜，冰箱。一扇窗户正对着十公里之外的外滩，能远远看到上海中心和环球金融中心。</p>
<p>偶尔，在大楼的间隙中，也能看到月亮。</p>
<p>曾经有一个朋友形容那高楼为巨兽，我深以为然。</p>
<p>我在上海的时候，怀念老家的闲适，怀念门口的田和老狗，于是过年前提前一天请了假回家过年。</p>
<p>回家了之后，又怀念忙碌的充实，怀念一个人的自在，于是在大年初五早上就回了上海。</p>
<p>等我到了站，下了车，匆匆的人群裹挟着冷风，迎面而来是一股说不出来的焦虑。</p>
<p>下午的时候，妈妈给我打了个视频电话，她说隔壁家的小侄女回外婆家了，我的表弟也回外婆家了，家里一下变得很冷清。</p>
<p>我知道她也想我。这时我开始后悔自己走得早。</p>
<p>我以前在微信公众号更新文章，她每一篇都看，都会评论，她是我唯一的忠诚读者。</p>
<p>但和她视频的时候，我没有说话。</p>
<p>我不知道该怎么和他们开口。</p>
<p>年岁渐长，说话的朋友却少了。很多当年的同学现在不回乡，而我也没有了寒暑假，今年终究没有和几个朋友见面。</p>
<p>稍微觉得有些孤单寂寞，除了一个月之前女朋友来上海的时候。</p>
<p>那几天过得很开心，因为疫情的原因居家办公。周末的时候，我们去了一些地方玩，上海野生动物园，上海迪士尼等。</p>
<p>有一天走在夜晚的街道上，我裹着她给我织的围巾，说再留两天吧。于是她又多待了一周。</p>
<p>但一周之后，她还是要走了。早上六点起床，去高铁站送她离开。</p>
<p>这样的离别我们已经经历过很多次，并且还要不知道经历多少次，可看着她的背影消失的时候，我还是忍不住流泪。</p>
<p>加快着脚步出站，又一次把自己埋到显示器的光里。</p>
<p>年后的第一个周末我又回家了，我给妈妈买了个新手机，是当年最好的安卓手机，给爸爸买了一身衣服。我回家的时候，爸爸坐在门口的阳光房晒太阳，把衣服给他，一刹那看到他眼中闪烁泪花。</p>
<p>人生一点点翻页，随着年龄的增长，生命的可能性逐渐被揭开。我们不再想，也不能成为科学家，或是宇航员。但我依然向往纯粹和浩瀚。</p>
<p>走过一段段路，开始自己做决定。那一个个选择造就了我们的过去和现在，又影响着我们的未来。我最近听到的很浪漫的一句话，在许许多多无数个平行宇宙里，一定有某个你做对了所有的选择，得到了最终的幸福。</p>
<p>但在无限的尺度上，我又不可能是那个完满的人。所以我的生活有遗憾，有徘徊。我确实想过，如果拥有另外一种人生会是怎样，但回望过去，我不对自己做出的任何选择后悔。</p>
<p>走吧。</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%9D%82%E6%84%9F/" rel="tag">杂感</a></li></ul>


    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
    <article id="post-如果我死了" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/11/12/%E5%A6%82%E6%9E%9C%E6%88%91%E6%AD%BB%E4%BA%86/"
    >如果我死了</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2022/11/12/%E5%A6%82%E6%9E%9C%E6%88%91%E6%AD%BB%E4%BA%86/" class="article-date">
  <time datetime="2022-11-12T13:44:02.959Z" itemprop="datePublished">2022-11-12</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      
      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
    <article id="post-LastNight" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/09/26/LastNight/"
    >LastNight</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2022/09/26/LastNight/" class="article-date">
  <time datetime="2022-09-25T16:08:36.000Z" itemprop="datePublished">2022-09-26</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%88%91%E4%BB%AC%E7%9A%84%E6%80%9D%E5%BF%B5/">我们的思念</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <p>明天是我转正答辩的日子。</p>
<p>——</p>
<p>9月17日，我放弃了保研资格。</p>
<p>我是可以保的。</p>
<p>心里堵得慌，当天晚上逃回家了。</p>
<p>第二天家里开始装修，电工师傅在排线，又觉得吵得紧，回上海。</p>
<p>我妈说我有空，我送你去吧。</p>
<p>去的时候在修路，有一条路临时开辟的，是单车道，我们走了那条单车道。</p>
<p>——</p>
<p>9月18日我回了上海。</p>
<p>上周四，9月22日，晚上十点，到小区门口发现钥匙没拿，于是回公司继续加班。</p>
<p>打了一辆车，上车的时候点开微信，发现有四天没有回复妈妈的消息了。</p>
<p>她每天给我发消息，问我吃饭了没，问我下班了没，问我这周末回来吗。</p>
<p>9月18日晚上23:32分，她给我发了这样一条消息</p>
<blockquote>
<p>儿子，我想跟你说，现在的你就像我们今天走的路一样，我们选择了一条单行道在这条路上因为不能超车不能加塞一般情况下会比旁边的3车道要快一点，但是也会有风险万一前面出状况了就进退两难了，虽然错过了一个出口还好顺利通过单行道，但愿你能顺利通过考核也相信你能通过考核，你那么努力那么优秀，加油</p>
</blockquote>
<p>上海的灯很亮，照着看不清。</p>
<p>——</p>
<p>我继续加班。当天是十二点走的。</p>
<p>——</p>
<p>第二天，周五，9月23日，下午六点有一场面试。</p>
<p>临时有了一个线上事故，面试前修。错过了面试。</p>
<p>八点修完，没吃饭，溜了。</p>
<p>又想逃，又想家了。</p>
<p>到了三门站，上车。打算坐到火车站。</p>
<p>但车门快关的时候，又下车了。</p>
<p>绕了个远路，坐地铁，又回到我的十平米不到的出租屋。</p>
<p>回家已经是九点多了。</p>
<p>——</p>
<p>上海这么大，我的容身之处却这么小。</p>
<p>躺在床上，扑面而来一股巨大的窒息感。</p>
<p>难受地想呕。</p>
<p>——</p>
<p>十点半，决定骑车去外滩。</p>
<p>共享单车，我有月卡，前120分钟免费。</p>
<p>上海变冷了，大概晚上只有十几度了，没带外套，穿了两件衬衫，一件短袖，一件长袖。</p>
<p>带了一瓶水，放在小黄车前面的车篮里，摇摇晃晃的。</p>
<p>——</p>
<p>我相信自己会一直在路上。</p>
<p>——</p>
<p>到了外滩是十一点半，骑了一小时，十公里。</p>
<p>东方明珠的灯也熄了，还有些三三两两的游人，都是结伴的。</p>
<p>黄浦江即使在夜晚也看着很浑浊。</p>
<p>算不得热闹，也算不得清冷。</p>
<p>——</p>
<p>吹了十分钟冷风，打了辆车回去。</p>
<p>车主刚开了四天滴滴，接我的时候，违章停车了。两个交警来罚他。</p>
<p>他哭腔说，能不能原谅一次啊，真的不容易啊。拿出一张刚在高架上被罚的罚单。</p>
<p>——</p>
<p>他白天工作，晚上出来开滴滴。他说他开到一两点回家。</p>
<p>他是92年的，但看着听着也年轻。</p>
<p>我知道他确实也不容易。</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%9D%82%E6%84%9F/" rel="tag">杂感</a></li></ul>


    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
    <article id="post-决定论" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/08/21/%E5%86%B3%E5%AE%9A%E8%AE%BA/"
    >决定论</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2022/08/21/%E5%86%B3%E5%AE%9A%E8%AE%BA/" class="article-date">
  <time datetime="2022-08-21T15:24:13.000Z" itemprop="datePublished">2022-08-21</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%88%91%E4%BB%AC%E7%9A%84%E6%80%9D%E5%BF%B5/">我们的思念</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <p>决定论</p>
<p>是谁让那二进制字符串，</p>
<p>编码成信笺上的落款？</p>
<p>让嘀嗒的文字，</p>
<p>从古旧的邮筒中飞出？</p>
<p>谁让那赶着寄信的人，</p>
<p>汗水升腾为天上的浮云？</p>
<p>又让那远隔千里的云，</p>
<p>在同一个冬天相聚？</p>
<p>是谁让雪落下，</p>
<p>在列车出站的一瞬间？</p>
<p>又让两只陌生的手，</p>
<p>掌纹逐渐缠绕在一起？</p>
<p>如果那年没有疫情，</p>
<p>我们就不会相遇。</p>
<p>如果那天你不在午后的窗边发呆，</p>
<p>我们就不会相遇。</p>
<p>如果那群白鸽没有飞过屋檐，</p>
<p>我们就不会相遇。</p>
<p>如果那时宇宙有了一个原子的改动，</p>
<p>我们就不会相遇了。</p>
<p>蚂蚁走不出莫比乌斯环，</p>
<p>在时间的尺度上，我们没有如果。</p>
<p>拉普拉斯妖告诉我，</p>
<p>从宇宙大爆炸那一刻起，</p>
<p>那些组成我们的物质，</p>
<p>就注定在一百五十亿年后相爱。</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AF%97/" rel="tag">诗</a></li></ul>


    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
    <article id="post-Summer" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/08/21/Summer/"
    >Summer</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2022/08/21/Summer/" class="article-date">
  <time datetime="2022-08-21T15:22:28.000Z" itemprop="datePublished">2022-08-21</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%88%91%E4%BB%AC%E7%9A%84%E6%80%9D%E5%BF%B5/">我们的思念</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <p>东山岛的夏让人回味。</p>
<p>那是我们想象中，海应该有的样子。</p>
<p>那辆三轮车送我们到海边的民宿。南国的岛民出乎意料的热情。</p>
<p>我们骑着租来的电瓶车在海边穿行，岛的尽头有一座石头城堡。通往另一个岛只有在退潮的时候才出现。第二天我们走过乱石，来到灯塔。太阳热烈，海风温柔，在沙滩上捡拾贝壳。</p>
<p>东山岛的另一端是东山，关帝庙精致，风动石长得像一只小动物。有彩色的房子，有长在古老城墙里的榕树。状似民居的博物馆，是我所见过的最质朴的博物馆，介绍着这块土地的历史。也能在山上看到远处的灯塔和其他岛屿。</p>
<p>夜晚的南门湾，有卖烤肠和年糕的流动车摊，有携手而归穿着校服的小情侣，有在路面唱情歌的人，他们的歌声里有故事。看过绽放的烟花，吹过潮湿的海风，走过细软的沙滩。海风把盐吹干在我们的脸上。一路上，人们坐在堤岸上打牌，聊天，喝酒。他们的生活闲适惬意。</p>
<p>金銮湾，渔民在那收网，与大海角力，直到天黑。记得那个大爷，我们与他攀谈。他记忆里的生活好苦。</p>
<p>记得我们在那踩沙子，让沙子把自己的腿埋起来。感受海浪从脚趾的间隙带走沙粒的感觉。看着远处的船逐渐返航，夜幕染黑深邃的大海，涛声起，只觉得世界寂静。</p>
<p>我们不能永远留在夏天，也不能永远留在东山，但东山的夏天永远有我们的回忆。</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%9D%82%E6%84%9F/" rel="tag">杂感</a></li></ul>


    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
    <article id="post-Day1" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/07/17/Day1/"
    >Day1</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2022/07/17/Day1/" class="article-date">
  <time datetime="2022-07-17T15:21:15.000Z" itemprop="datePublished">2022-07-17</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%88%91%E4%BB%AC%E7%9A%84%E6%80%9D%E5%BF%B5/">我们的思念</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <p>Day1</p>
<p>写下这些文字的时候，Day1已经过去好几天了。</p>
<p>尤其是在凌晨的时候，醒来许多次。总觉得鼻上有股若隐若无的臭味。</p>
<p>回头来看，我或许错怪了这酒店，或许我在厦门买的那双橡胶拖鞋才是散发出那股莫名气味的罪魁祸首。</p>
<p>但那卫生间也不无关系吧。</p>
<p>早上走的时候线上入职的流程。中午，我急不可耐地企望前往工区。在飞书上和mentor联系，然后打的前往。</p>
<p>尚浦中心，那些在阳光下反射出刺眼光线的楼围在一起，形成了一片园区。中午的时候，这里有许多带着工牌的人在结伴而行。带着工牌的，大部分是字节员工。</p>
<p>我的mentor是一个中年人了。这从他的飞书和微信头像上也得以窥见：他的头像是自己的孩子。</p>
<p>在向上，mentor的直属上级、mentor直属上级的直属上级、mentor直属上级的直属上级的直属上级，他们用的都是自己孩子的头像。</p>
<p>那些云淡风轻的某一天，回头看来，其实是人生一个重大的转折点。</p>
<p>人生总有很多第一次。第一次上学，第一次谈恋爱，第一次工作……当某天回忆过去的时候，才发现生命不过是以“帧”为单位的幻灯片而已。</p>
<p>这一天或许也是这样吧。</p>
<p>……</p>
<p>我和同组的几个同学，以及leader一起去吃饭。</p>
<p>在组内大家一起结伴去吃饭似乎是一种常态。</p>
<p>几位同学看上去非常年轻，和学校里的同学没有什么差别。着装也是这样。这多少冲淡了一些我的拘谨。</p>
<p>字节的食堂是流水线形式的自助餐。排队，走，取餐。称不上特别丰盛，但足以满足任何口味的人的胃口。另有水果、饮料可以自取。而且全免费。这一点来说，确实是很划算了。</p>
<p>我挑的东西不多。大抵是因为那一天太热的原因，实在是没有胃口。自助餐总是容易浪费，特别是在不要求你全部吃完的情况下。而得以我只拿了寥寥几个菜的缘故，我是吃的最干净的。</p>
<p>回到工区，坐下没多久。听到外面有封楼的消息。同学全部站在楼边向外看了，我却还有些不以为然。</p>
<p>我打趣道”不会我的线下实习生活只有这么半小时吧。“</p>
<p>是的，成真了。</p>
<p>这时候我才意识到，疫情给我们生活真的带来了改变。</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%9D%82%E6%84%9F/" rel="tag">杂感</a></li></ul>


    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
    <article id="post-EVE" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/07/12/EVE/"
    >EVE</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2022/07/12/EVE/" class="article-date">
  <time datetime="2022-07-12T11:58:04.000Z" itemprop="datePublished">2022-07-12</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%88%91%E4%BB%AC%E7%9A%84%E6%80%9D%E5%BF%B5/">我们的思念</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <p>昨晚，没有睡好。</p>
<p>这并不是由于失眠，或者精神衰弱。仅仅是甘于沉溺在精神鸦片营造的虚拟里。</p>
<p>窗帘渐渐泛起亮光的时候，我意识到不得不睡了。</p>
<p>凌晨两点收拾行李的时候，我带了一条空调被，严实地压缩在一半的行李箱空间里；从抽屉里拿了半抽屉的衣物，短袖、短裤、袜子。又置了一件黑色的衬衣外套，这是女友给我买的，以及一条长裤。然后是身份证、学生证、剃须刀，指甲刀，风油精，伞……</p>
<p>它们被一股脑塞进电脑包前面的夹层里。</p>
<p>可还是总觉得少了些什么。</p>
<p>于是拿走了桌面上的那张照片——我们在长沙用拍立得拍的，那时她微卷了头发，侧站在帘前，傍晚的阳光穿过半透明的纱，拂在我们的脸上。</p>
<p>在学校的时候，我把这张照片贴在桌上的小书架旁。于是我也期望今后也能把这张照片带着。</p>
<p>可我仍感觉少了些什么。</p>
<p>……</p>
<p>前些日子，又和她吵架了。</p>
<p>关于未来要去哪个城市定居的事。关于未来要如何生活的事。</p>
<p>想着这些事，总觉得太早。不想，总觉得太慌。想想，多少就有了些期盼。再想想，又觉得要战胜的困难实在太多。</p>
<p>我说，大城市生活压力大，要还三十年房贷。小城市工作机会少，只能去开滴滴。</p>
<p>我说，考虑未来十年买房实在不是好时机。</p>
<p>我说，现在的国际形势和经济情况似乎不容乐观。</p>
<p>我说，就业一年不如一年了。</p>
<p>我说，我们还是应该从理性的角度出发，作出更符合长远利益的选择。</p>
<p>但她说，我只是想要一个家而已。</p>
<p>那么，我会给你一个家的。</p>
<p>……</p>
<p>母亲载我到嘉定北。</p>
<p>我不是第一次到嘉定北乘地铁，但这次的感受似乎不太一样。</p>
<p>一班公交车停了下来，然后快步走出一群年轻男女。</p>
<p>这些通勤的人们，无一例外脸上带着淡漠。他们以一种近乎麻木的状态快速行进着。</p>
<p>他们的身上裹挟着大上海争分夺秒的焦虑，这焦虑同样体现在处心积虑设计的地铁时间表上：你只有快走，快走，快走，才能伴着关门的铃声赶上下一班换乘的车。</p>
<p>我在车站下的肯德基解决了自己的早餐。</p>
<p>猪肉芝士帕尼尼、美式咖啡、一个蛋挞、一根肠，十五块。</p>
<p>咖啡实在是很烫，直到其他食物都吃完，我才能开始用那根细吸管去啄咖啡。</p>
<p>约莫八点二十，我上了地铁。转一站。十一号线坐一小时，八号线坐一小时，顶着太阳步行一点六公里。</p>
<p>于是到了提前预定的海友酒店。</p>
<p>当然，你不能对位于上海五角场旁边的一百六十元一晚的酒店抱有期待。但它在网站上写着“2020年开业“，想着应该也不会那么差。</p>
<p>可当目睹它真容的时候，我感到一阵失望。</p>
<p>走廊和电梯像是切尔诺贝利核爆炸之后无人维护二十年的废墟。</p>
<p>房间表面上是整洁的，但禁不住打量。</p>
<p>卫生间的水渍未干。枕头是湿的，或许是我的汗浸润的。插上房卡的一瞬间，电视机开始自动打开并且播放东方卫视的电视节目。从它的显示画质和方式来看，出生日期应该在十年之前。</p>
<p>马桶圈有裂纹。坐上去能让你的下体享受天然瓷砖纹理按摩服务，当然，这是智能马桶所不具备的高级享受。</p>
<p>至于空调漏水和房间里有小飞虫这些事，则显得无关紧要了。</p>
<p>……</p>
<p>对于未来的实习生活，我不由得产生一些陌生、焦虑与恐惧的情绪。</p>
<p>mentor加了我微信。</p>
<p>不知该如何去和他打招呼。第一句话，说“你好”是否显得太陌生，说“hello或者哈喽”是否显得太轻佻。说“您好”又是否太疏离。或许我该先做一个自我介绍，那又会不会显得太多余。</p>
<p>巧，他的名字第二个字也是下雨的意思。</p>
<p>他唯一的朋友圈，发在半年前。是二十三点下班打车回家的事情。</p>
<p>中午做了个幻想职场美好生活的梦。</p>
<p>带着一身汗臭入睡，醒来的时候去楼下做了个核酸。天空中忽然飘起淅淅沥沥的小雨，竟没有那么闷热了。</p>
<p>点了一份脆皮五花肉。原价40，会员5元的券可以减11，但会员要8元买两张5元的券。这算数太过复杂，我算不过来。</p>
<p>所幸刷脸让付钱变得很容易。</p>
<p>糟糕的一餐。</p>
<p>店家发明了脆皮五花肉和北京烤鸭结合的吃法，也即是用面皮包着肉，附上生菜和酱汁。这是我头一次吃到。</p>
<p>这脆皮脆的也太过正宗，坚硬如石头。咬下一口，只觉得舌头被搅得生疼。</p>
<p>到晚上七点，我再次啃了几块剩下的脆皮五花肉。</p>
<p>……</p>
<p>洗了个澡，无可避免地把卫生间的地面弄湿了。卫生间渐渐升腾起一股湿臭的下水道气息。所幸有门隔绝，算得是两个世界。</p>
<p>窗外巨大的防盗窗，如同一座牢房笼罩在我的头上。这窗户看不到夕阳，只能看到一点点阴沉的破旧街道。</p>
<p>于此时，心中升起一股可怖的寂寥。</p>
<p>独自一人生活，还属头一回。</p>
<p>在这座城市里，没有友人，没有爱人，没有亲人。</p>
<p>曾以旅客心态路过她的时候，只觉得对一切好奇。因为我心里知道，我有一个能回去的地方。</p>
<p>而今天，面临未知的职场。还无头绪的租房，濒临爆发的疫情，日益增长的就业和生活压力。</p>
<p>这个社会不停地创造着无形的手臂，缠住你、拖住你、拉扯你、直到撕裂你。</p>
<p>然后又用那些虚拟的快乐麻痹你，让人可以短暂忘却现实的苦楚。</p>
<p>可悲的是，我即将要做的，正是这样要将人推入深渊的事情。</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%9D%82%E6%84%9F/" rel="tag">杂感</a></li></ul>


    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
    <article id="post-TheNight" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/04/26/TheNight/"
    >TheNight</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2022/04/26/TheNight/" class="article-date">
  <time datetime="2022-04-26T15:22:20.000Z" itemprop="datePublished">2022-04-26</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%88%91%E4%BB%AC%E7%9A%84%E6%80%9D%E5%BF%B5/">我们的思念</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <p>我不太会写信。</p>
<p>在信里，我做的最多的事情是解构自己，暴露自己，以这样的行为来渴望贴近距离。</p>
<p>还剩一面墙的墙纸没贴。</p>
<p>发觉自己做事总是在燃烧热情，而渐渐对生活失去掌控。</p>
<p>如布置房间，打印了很多照片，买了钉子，想着贴。如修理屋子里那些不好用的设备，像洗衣机和热水器。</p>
<p>明知道这些事是要做的，却打不起去做的精神。</p>
<p>打开冷水洗澡的时候，觉得水冰冷得可怕。淋到身上的时候，又觉得不是那么难以忍受。</p>
<p>空调的冷气带走水汽的过程吸走了最后一点热量，头皮像被针刺般的麻木了。</p>
<p>有着这样出人的折磨自己的忍耐力。也在想，是否我的灵魂在痛恨着这个躯壳。</p>
<p>我想我要做的事情还要很多，我有必要让我的家变得更温馨一些，我有必要去看看我的牙，看看我的胃。我有必要再为了工作和生活努力一把。</p>
<p>又觉得好累。最享受的时间，是我躺在床上，侧躺着看小说。其实小说并不好看，但直到精神被麻醉了，眼睛感到困倦了，才能睡得安心。</p>
<p>睡一场周六的午觉是我最觉得安心的时候。</p>
<p>我想起在家被肿瘤缠身的那只老狗。狗已经很老了，但她应该还能活。我的父母，我的爷爷，他们把狗当成亲爱的家人，却不愿意给她出个几千块钱去治好这瘤子。他们把消炎药塞到香肠里给狗吃，狗好了一些了。</p>
<p>狗的瘤子仍然烂了，像个破皮的石榴，不断地向外涌着脓血。她不再上沙发睡觉。沙发是她最爱的地方。</p>
<p>她躺在冰冷的地板上，不再有脚力快乐地奔跑了。她的脓血在家的大厅里散发出一阵阵腥气。母亲用拖把拖了好多遍，还是有。</p>
<p>他们不断地把这只狗赶出大厅，然后拖地。</p>
<p>父亲又捉了一只狗回家，卷毛。</p>
<p>我梦到那只狗了。我觉得心里无比的疼痛。</p>
<p>我想起小学的时候我养的狗。有一只是圣诞节一个叔叔给我的礼物，伴随着他的是一只小白狗玩偶，我给他们都取名叫圣诞。我抱着那只毛茸茸的小白狗玩偶睡觉。圣诞被养在厨房后面的一个小房间。我爸养了一只大黄狗，把我的圣诞咬死了。</p>
<p>我想起另外一只狗，它生了不知道什么病，浑身流脓。躺在家里二楼的走廊里，血和脓水淌在地上。我想求我爸爸治好他。一天，他被我爷爷扔了。</p>
<p>我想起我孵的一个蛋。那个蛋本来是不该活的。我用电筒照它，用餐巾纸给它做巢，不知道怎么把它孵出来了。小鸡来到这个世界上，活了两天。</p>
<p>我想起那只小鸭子，从我家后面的河里游过来的。来的时候，它的脚上流着血。我给它喂东西，给它包扎。它也活了两天。我把它葬在它来的那条河里。</p>
<p>我想起我姐姐家养的一只小黑狗，我们是那么的爱它。然后姐姐家的狗被我姐姐的家人杀了吃狗肉。那天晚上我伤心极了，离家出走了。那是我第一次离家出走。</p>
<p>我梦到阿黄了。</p>
<p>我想如果我再回去，她可能已经死了。</p>
<p>我或许是可以救她的，但我没有。</p>
<p>我相信父母和爷爷说爱那只狗，不是假的。</p>
<p>但他们不愿意为了这只狗付出几千块的医药费。</p>
<p>因为说到底，狗就只是狗。</p>
<p>我感到心里无比的疼痛，而泪流满面了。</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%9D%82%E6%84%9F/" rel="tag">杂感</a></li></ul>


    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
    <article id="post-我和我的世界" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/04/24/%E6%88%91%E5%92%8C%E6%88%91%E7%9A%84%E4%B8%96%E7%95%8C/"
    >我和我的世界</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2022/04/24/%E6%88%91%E5%92%8C%E6%88%91%E7%9A%84%E4%B8%96%E7%95%8C/" class="article-date">
  <time datetime="2022-04-23T17:27:08.000Z" itemprop="datePublished">2022-04-24</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <p>十年回忆录，我和我的世界。深夜有所感想，所以想写些东西，聊以自娱。多年来记忆已经模糊，如有错漏之处，还请谅解。不知道我的经历是否会引起你的共鸣，也让你回想起最初面对一个波澜壮阔的世界时的感动呢？</p>
<p>最近，我又开始玩Minecraft。</p>
<p>第一次接触这个游戏，还是在我小学四年级的时候。Minecraft的贴吧注册会员似乎也只有几千个，国内最大的服务器大概也不过几十人、百来人。彼时流行的还是1.0版本。对我而言，一切都是新奇的。记得我的一个存档是在一个树木很少的冰原，玩的创造模式。我掏出了一个山洞，然后把所有的墙壁都换成了钻石块和金块。</p>
<p>我在一个叫1.3原版生存直播的帖子里学到很多知识，作者是defanive2。然后，也开始学会看wiki。了解了游戏的更多机制，便越发对这个能够自由创造的世界着迷了。还有几位印象比较深的实况主，如蓝色铁卷门、12dora。</p>
<p>在每一节能够自由活动的体育课和活动课上，别的同学去踢球、打乒乓，而我总是坐在树下的椅子上，不遗余力地向小伙伴们推荐这个游戏。说来也奇怪，那时我总是能滔滔不绝讲上很久的游戏内容和各种机制。也有好几个小伙伴被我说动，但却止步于安装Java、以及联机各种操作的繁琐。现在想来是有些遗憾的。</p>
<p>上了初中之后，换了新电脑。学业有些紧张了，而我却更沉迷于建造自己的世界。有了几个固定玩耍的、和我年纪相仿的朋友。我用小笔记本，开着供几个人玩耍的小服务器。是用hamachi联机的。每次打开电脑，我就会使用hamachi。其频率比QQ还高。</p>
<p>我用自己的昵称当做种子，生成了一个海岛地图，离出生点大概一两百格的地方，就有一个蘑菇岛。也学会开始用WE，照着贴吧里的各种教程来建房子，然后建一座自己的城市。</p>
<p>可我的存档常常丢——那时我电脑的主板烧坏了许多次，或是因为可乐泼在键盘上了，或是因为电脑放在被子上没关就睡着了。那时做的东西很稚嫩，却总能乐在其中。</p>
<p>这段日子我在找实习，就业形式的急转直下、对于未来的迷惘都一度使我陷入难眠的焦虑。不止一次回想起少年时期的那段日子，在互联网构成的虚拟世界中度过的时光，它们好像已经太渺远，但又太精彩而美好。</p>
<p>我和我的小伙伴们不仅玩MC，也玩泰拉瑞亚、teeworlds、cubeworld、王牌黑桃、pokemmo等等游戏。其中一个叫Siu12321，另一个叫MmMmM。我们从未在现实中见过一面，也已经很长时间没有交往。可那段时光是我至今看来都无比快乐的。我和MmMmM的正版账号是Siu送的。那时国内想要买正版并不容易，许是要找人代购的。Siu是澳门人，有一次去香港旅游，买到了Minecraft的礼品卡。然后我们三个人起了格式一样的名字，XxRyexX，XxSiuxX，XxMmMmMxX。我想起写这些文字，也是在用玩家头颅做一些装饰的时候，突然想起了这三个ID。</p>
<p>事实上在那个年代，很多人是视游戏为洪荒猛兽的。在家长眼里，网上认识的朋友都是骗子。而对我来说，一百多元的人民币的MC账号可真是巨款——校门口的汉堡大概五块，或是六七块，总之不超过十块。我自己是不敢想象能够花钱给网友送礼物的。直到今天，我仍然很感谢这个赠送我正版账号的朋友，以及那些我们一起度过的时光。现实中，有些人即使和你近在咫尺，也不会真正了解。有些人虽和你远隔千里，却能有相同的志趣、相同的爱好，能够分享快乐也彼此依赖。这或许就是信息时代带给我们的宝贵东西吧。</p>
<p>1.6和1.7都是经典的版本，到那时玩这个游戏的人可是真多了，称得上是勃勃生机万物竞发的场面。后来我在一个服务器里，靠建筑获得了服主的赏识，做了op。那时候搞过暮色森林和神奇宝贝服。服务器里有比较懂的技术人员，也有靠谱的管理。大家为了一起办好服务器做了很多努力。之后，服主去当兵了，约定三年回来之后重新开服。</p>
<p>高中终于有了晚自习。九点多、十点多才能回家，以及周六也得上学。即使偶有闲暇功夫，也必须埋头在雪花一般的试卷堆里。终于没有时间玩MC了。之前的服主退役回来后，服务器却也没有再开了。高考结束，好歹是考上了大学，似乎终于解放了。看着好友列表里灰暗的头像，几年没有联系过的朋友，终究是没有再联系的勇气。</p>
<p>凭借着小时候对计算机的着迷——即使一直都是瞎玩，从来没有学过编程或是专业的计算机技术，我毅然决然选择了计算机专业。由于做实验需要开虚拟机编译内核，而我的电脑硬盘又不太够，于是买了一个云服务器。在写完实验之后，又拿它来开服。我建造了一些学校里的建筑，以此来祭奠我即将结束的、被疫情搅乱的大学生活，我怀念的美丽校园和其他一切的美好。这些年间，并不是完全没有再玩过MC，只是终究不像以前一样，对每一个机制都如数家珍。当我时隔许久重新踏足这个由像素和方块组成的土地时，我对很多东西都感到陌生：为什么会有黑脸的村民？为什么水下会长草？为什么晚上不睡觉会被奇怪的生物袭击？这些重又勾起我的好奇，而这个世界仍然让我心潮澎湃。前段时间流行一句话，叫“走出半生，归来仍是少年”。对我而言，十一年可真真称得上是半生了。</p>
<p>这半生，称得上是愚钝，作为国内很早的一批MC玩家，我可以说是什么都不会。建筑、红石样样不通，虽然是计算机专业的，却也还没试着写模组或者插件。精心建设的存档，一次次丢失了。就像我们人生的一个个阶段，总是要不断地和过去说再见。</p>
<p>到了今天，让我烦恼的事情已经不再是考试没考好、或是假期快要结束了而作业没开始写。甚至我已经逐渐开始难以理解，那不就是一些很小的事情吗，为什么那时候我会觉得好像天要塌了一样？而或许，我今天所烦恼的，在将来的我看来也不过是很小的事情罢。</p>
<p>那么就让我们再次启程出发，重新怀着对世界的好奇和热爱。</p>
<p>谢谢你读到这里，祝你好。</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
    <article id="post-面经整理" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/03/17/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86/"
    >面经整理</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2022/03/17/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86/" class="article-date">
  <time datetime="2022-03-16T16:39:16.000Z" itemprop="datePublished">2022-03-17</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <p>[TOC]</p>
<h1 id="求职八股文整理"><a href="#求职八股文整理" class="headerlink" title="求职八股文整理"></a>求职八股文整理</h1><h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><h3 id="1、指针和引用的区别"><a href="#1、指针和引用的区别" class="headerlink" title="1、指针和引用的区别"></a>1、指针和引用的区别</h3><ul>
<li>指针是一个变量，存储的是一个地址；引用是原来变量的别名。</li>
<li>指针可以有多级（指针的指针），引用只有一级。</li>
<li>指针可以为空，引用不能为空且必须初始化。存在指向空值的指针，不存在指向空值的引用。</li>
<li>指针在初始化后可以改变指向，引用不行。</li>
<li>sizeof指针得到本指针的大小，sizeof引用得到引用所指变量的大小。</li>
</ul>
<h3 id="2、堆和栈的区别"><a href="#2、堆和栈的区别" class="headerlink" title="2、堆和栈的区别"></a>2、堆和栈的区别</h3><ul>
<li>申请方式不同。栈由系统自动分配，堆是自己申请、释放的。</li>
<li>申请大小限制不同。栈顶和栈底是之前预设好的。栈向栈底拓展，向下增长，大小固定。堆向高地址拓展，是不连续的内存区域，大小可以灵活调整。</li>
<li>申请效率不同。栈由系统分配，速度快，不会有碎片。堆由程序员动态分配，速度慢，会有碎片。</li>
<li>栈默认空间是4M，堆一般是1G - 4G</li>
</ul>
<h3 id="3、C-11有哪些新特性？"><a href="#3、C-11有哪些新特性？" class="headerlink" title="3、C++11有哪些新特性？"></a>3、C++11有哪些新特性？</h3><ul>
<li>nullptr代替NULL</li>
<li>引入了auto和decltype这两个关键字实现类型推导。<ul>
<li>auto能让编译器替我们去分析表达式所属的类型。auto必须有初始值。</li>
<li>decltype选择并返回操作数的数据类型，但不进行实际的计算表达式的值。</li>
</ul>
</li>
<li>Lambda表达式（匿名函数）<ul>
<li>可以编写内联的匿名函数，用以替换独立函数或函数对象。</li>
</ul>
</li>
<li>右值引用和move语义。</li>
<li>基于范围的for循环。for（auto&amp; i : res){}</li>
<li>…</li>
</ul>
<h3 id="4、智能指针的原理、常用的智能指针。"><a href="#4、智能指针的原理、常用的智能指针。" class="headerlink" title="4、智能指针的原理、常用的智能指针。"></a>4、智能指针的原理、常用的智能指针。</h3><p>原理：智能指针是一个类，用来存储指向动态分配对象的指针，负责自动释放动态分配的对象，防止堆内存泄漏。类对象声明周期结束时，自动调用析构函数释放资源。</p>
<p><strong>为了更好地管理堆内存。</strong></p>
<p>常用的智能指针有（1）shared_ptr，（2）unique_ptr，（3）weak_ptr，（4）auto_ptr</p>
<p>（1）shared_ptr采用引用计数，每一个shared_ptr的拷贝都指向相同的内容，当最后一个shared_ptr析构的时候，内存被释放。</p>
<p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shared_ptr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 空参构造 空指针</span></span><br><span class="line">    Shared_ptr():count(<span class="number">0</span>), _ptr((T*)<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="comment">// 构造函数 count必须new出来</span></span><br><span class="line">    Shared_ptr(T* p) : count(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>)), _ptr(p) &#123;&#125;</span><br><span class="line">    <span class="comment">// 拷贝构造函数 使其引用次数加一</span></span><br><span class="line">    Shared_ptr(Shared_ptr&lt;T&gt;&amp; other) : count(&amp;(++ *other.count)), _ptr(other._ptr) &#123;&#125;</span><br><span class="line">    <span class="comment">// 重载operator*和operator-&gt; 实现指针功能</span></span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() &#123; <span class="keyword">return</span> _ptr; &#125;</span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() &#123; <span class="keyword">return</span> *_ptr; &#125;</span><br><span class="line">    <span class="comment">// 重载operator=</span></span><br><span class="line">    <span class="comment">// 如果原来的Shared_ptr已经有对象，则让其引用次数减一并判断引用是否为0.（是否调用delete）</span></span><br><span class="line">    <span class="comment">// 然后将新的对象引用次数加一。</span></span><br><span class="line">    Shared_ptr&lt;T&gt;&amp; <span class="keyword">operator</span>=(Shared_ptr&lt;T&gt;&amp; other)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other)</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        </span><br><span class="line">        ++*other.count;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_ptr &amp;&amp; <span class="number">0</span> == --*<span class="keyword">this</span>-&gt;count)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> count;</span><br><span class="line">            <span class="keyword">delete</span> _ptr;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"delete ptr = "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_ptr = other._ptr;</span><br><span class="line">        <span class="keyword">this</span>-&gt;count = other.count;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//析构函数，使引用次数减一并判断引用是否为0</span></span><br><span class="line">    ~Shared_ptr()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(_ptr &amp;&amp; --*count == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">delete</span> count;</span><br><span class="line">            <span class="keyword">delete</span> _ptr;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"delete ptr ~"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getRef</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *count; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span>* count;</span><br><span class="line">    T* _ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="5、简要说明C-的内存分区。"><a href="#5、简要说明C-的内存分区。" class="headerlink" title="5、简要说明C++的内存分区。"></a>5、简要说明C++的内存分区。</h3><p>分别有栈、堆、自由存储区、全区/静态存储区、常量存储区和代码区。</p>
<p><strong>栈</strong>：在执行函数时，函数内局部变量的存储单元可以在栈上创建，函数执行结束时，这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率高但内存容量有限。</p>
<p><strong>堆</strong>：由new分配到的内存块，需要手动delete释放。</p>
<p><strong>自由存储区</strong>：通过new和delete动态分配和释放对象的抽象概念。</p>
<p><strong>全局/静态存储区</strong>：全局变量和静态变量被分配到同一块内存中。若没有初始化则会自动初始化。</p>
<p><strong>常量存储区</strong>：存放常量不允许修改。</p>
<p><strong>代码区</strong>：存放函数体的二进制代码。</p>
<h3 id="6、什么是内存池"><a href="#6、什么是内存池" class="headerlink" title="6、什么是内存池"></a>6、什么是内存池</h3><p>内存池是一种<strong>内存分配</strong>方式。是在真正使用内存之前，先申请分配一定数量的、大小相等（一般情况下）的内存块留作备用。当有新的内存需求时，就从内存池中分出一部分内存块。若内存块不够再继续申请新的内存。</p>
<p>避免了内存碎片，使得内存分配效率得到提高。</p>
<h3 id="7、C-中的重载、重写（覆盖）和隐藏"><a href="#7、C-中的重载、重写（覆盖）和隐藏" class="headerlink" title="7、C++中的重载、重写（覆盖）和隐藏"></a>7、C++中的重载、重写（覆盖）和隐藏</h3><ul>
<li><p>重载（overload）</p>
<ul>
<li>重载是在同一范围定义中的同名成员函数才存在重载关系。主要特点是函数名相同，参数类型和数目有所不同。返回值也可以不同。</li>
</ul>
</li>
<li><p>重写（覆盖）（override）</p>
<ul>
<li>重写指的是在派生类中覆盖基类中的同名函数。重写就是重写函数体，函数必须是虚函数且与基类的虚函数有相同的参数个数、类型、返回值。</li>
</ul>
</li>
<li><p>隐藏（hide）</p>
<ul>
<li>隐藏指的是某些情况下，派生类中的函数屏蔽了基类中的同名函数。</li>
</ul>
</li>
</ul>
<h3 id="8、深拷贝和浅拷贝的区别"><a href="#8、深拷贝和浅拷贝的区别" class="headerlink" title="8、深拷贝和浅拷贝的区别"></a>8、深拷贝和浅拷贝的区别</h3><ul>
<li>浅拷贝<ul>
<li>浅拷贝只是拷贝一个指针，并没有新开辟一个地址，拷贝的指针和原来的指针指向同一块地址，如果原来的指针所指向的资源释放了，那么再释放浅拷贝的指针的资源就会出现错误。</li>
</ul>
</li>
<li>深拷贝<ul>
<li>深拷贝不仅拷贝值，还开辟一块新空间来存放新的值。即使原来的对象被释放掉内存也不会影响深拷贝得到的值。</li>
</ul>
</li>
</ul>
<h3 id="9、面向对象的三大特性（字节1）"><a href="#9、面向对象的三大特性（字节1）" class="headerlink" title="9、面向对象的三大特性（字节1）"></a>9、面向对象的三大特性（字节1）</h3><p>面向对象的思想是从客观存在的事物出发来构造软件系统，以事物为中心来思考问题，认识问题，这样子构建起来的系统才符合现实世界的本来面目。</p>
<p>面向对象对应的是面向过程。面向对象不围绕功能来构造系统。</p>
<p>三大特性：继承、封装和多态</p>
<p><strong>（1）继承</strong></p>
<p><strong>让某种类型对象获得另一个类型对象的属性和方法。</strong></p>
<p>可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行拓展：</p>
<p>继承有三种方式：</p>
<ol>
<li>实现继承：指使用基类的属性和方法而无需额外编码的能力</li>
<li>接口继承：指仅使用属性的方法和名称、但是子类必须提供实现</li>
<li>可视继承：指子窗体（类）使用基窗体（类）的外观和实现代码</li>
</ol>
<p><strong>（2）封装</strong></p>
<p>数据和代码捆绑在一起，避免外界干扰和不确定访问。</p>
<p>封装，也就是<strong>把客观事物封装成抽象的类</strong>。</p>
<p><strong>（3）多态</strong></p>
<p>允许将父对象设置成和一个或更多的子对象相等的技术。</p>
<p>将子类类型的指针赋值给父类类型的指针。</p>
<p>实现多态：覆盖（override），重载（overload）</p>
<h3 id="10、虚函数（字节1）"><a href="#10、虚函数（字节1）" class="headerlink" title="10、虚函数（字节1）"></a>10、虚函数（字节1）</h3><p>虚函数主要是为了实现多态的机制。</p>
<p>在基类的函数前面加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。</p>
<p>存在虚函数的类内部有一个一维的虚函数表叫做虚表，虚表存放着该类所有的虚函数对应的函数指针，指明了实际需要调用的函数。</p>
<p>纯虚函数是在基类中生命的虚函数，要求派生类去定义自己的实现方法。虚函数加载上一个 = 0。抽象类是指包括至少一个纯虚函数的类。抽象类必须在子类实现这个函数，现有名称，没有内容，在派生类实现内容。</p>
<h3 id="11、构造函数有几种"><a href="#11、构造函数有几种" class="headerlink" title="11、构造函数有几种"></a>11、构造函数有几种</h3><ul>
<li>默认构造函数</li>
<li>初始化构造函数<ul>
<li>默认构造函数和初始化构造函数，在定义类的对象的时候，完成对象的初始化工作。</li>
</ul>
</li>
<li>拷贝构造函数<ul>
<li>默认实现浅拷贝。</li>
<li>只定义析构函数，就会生成拷贝构造函数和默认构造函数。</li>
</ul>
</li>
<li>移动构造函数<ul>
<li>用于将其他类型的变量，隐式转换为本类对象。</li>
</ul>
</li>
</ul>
<h3 id="12、一个类默认会生成哪些函数"><a href="#12、一个类默认会生成哪些函数" class="headerlink" title="12、一个类默认会生成哪些函数"></a>12、一个类默认会生成哪些函数</h3><ul>
<li>无参的构造函数</li>
<li>拷贝构造函数</li>
<li>赋值运算符</li>
<li>析构函数</li>
</ul>
<h3 id="13、类的初始化顺序"><a href="#13、类的初始化顺序" class="headerlink" title="13、类的初始化顺序"></a>13、类的初始化顺序</h3><p>父类构造函数——&gt;成员类对象构造函数——&gt;自身构造函数</p>
<h3 id="14、什么是内存泄漏？内存泄漏怎么检测"><a href="#14、什么是内存泄漏？内存泄漏怎么检测" class="headerlink" title="14、什么是内存泄漏？内存泄漏怎么检测"></a>14、什么是内存泄漏？内存泄漏怎么检测</h3><p>申请了一块内存空间，使用完之后没有释放掉。</p>
<p>（1）new和malloc申请资源使用后，没有用delete和free释放。</p>
<p>（2）子类继承父类时，父类析构函数不是虚函数</p>
<p>（3）Windows句柄资源使用后没有释放</p>
<p><strong>怎么检测？</strong></p>
<p>1.人工检测：养成良好的编码习惯，使用完毕之后用函数释放</p>
<p>2.使用智能指针</p>
<p>3.用一些工具插件</p>
<h3 id="15、malloc和new的区别（字节1）"><a href="#15、malloc和new的区别（字节1）" class="headerlink" title="15、malloc和new的区别（字节1）"></a>15、malloc和new的区别（字节1）</h3><p><strong>malloc</strong></p>
<p>开辟一块长度为size的连续内存空间，返回类型为void的指针。开辟失败返回NULL。</p>
<p><strong>new</strong></p>
<p>返回所分配的内存单元的起始地址，需要把返回值保存在一个指针变量中。</p>
<ol>
<li>malloc/free是标准库函数，new/delete是c++运算符</li>
<li>malloc失败返回空，new失败抛出异常</li>
<li>new/delete会调用构造析构函数，malloc/free不会，所以他们无法满足动态对象的要求。</li>
<li>new返回有类型的指针，malloc返回无类型的指针。</li>
<li>malloc从堆上动态分配内存，new从自由存储区为对象分配内存。自由存储区不仅可以为堆，还可以是静态存储。</li>
</ol>
<h3 id="16、C-volatile关键字"><a href="#16、C-volatile关键字" class="headerlink" title="16、C++ volatile关键字"></a>16、C++ volatile关键字</h3><p>类型修饰符，指示说明对它所修饰的对象不应该执行优化。如果没有volatile，没有办法在多线程并行中使用到基本变量。</p>
<p>如果一个基本变量被volatile修饰，编译器不会把它保存到寄存器中，而是每一次都去访问内存中实际保存该变量的位置，可以避免变量在多线程读写中因为编译器优化所导致的问题。</p>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="1、进程和线程和协程的比较（字节1）"><a href="#1、进程和线程和协程的比较（字节1）" class="headerlink" title="1、进程和线程和协程的比较（字节1）"></a>1、进程和线程和协程的比较（字节1）</h3><p>1、<strong>进程是资源调度的基本单位，线程是程序执行的基本单位。</strong>协程是微线程。</p>
<p>2、<strong>线程</strong>的启动速度快，轻量级，系统开销小。<strong>进程</strong>系统开销大。</p>
<p>3、一个线程从属于一个进程，一个进程可以包含多个线程。</p>
<p>4、<strong>进程</strong>在执行时拥有独立的内存单元。</p>
<p>​      多个<strong>线程</strong>共享进程的内存，如代码段，数据段等，但拥有自己的栈段和寄存器组。线程需要处理数据一致性的问题。</p>
<p>5、通信方式不一样。进程通信需要借助操作系统，线程可以直接读写进程数据段（如全局变量）来通信。</p>
<p>6、进程切换需要刷新TLB并获取新的地址空间，然后切换硬件上下文和内核栈。线程切换只需要切换硬件上下文和内核栈。</p>
<p>进程：进程是程序的运行实例，包括程序计数器、寄存器和变量。</p>
<p>线程：微进程，一个进程里包含多个线程并发执行任务。</p>
<p>协程：协程是微线程，在子程序的内部执行，可以在子程序内部中断，转而执行别的子程序，在适当的时侯回来接着执行。协程上下文切换非常快，效率快。</p>
<h3 id="2、进程通信方式？"><a href="#2、进程通信方式？" class="headerlink" title="2、进程通信方式？"></a>2、进程通信方式？</h3><p>在不同的操作系统下，进程有不同的通信方式。</p>
<p>Linux下进程通信方式：</p>
<ul>
<li>管道<ul>
<li>无名管道（内存文件）：管道是一种<strong>半双工</strong>的通信方式，数据只能单向流动，只能在有<strong>亲缘关系</strong>的进程之间使用。</li>
<li>有名管道（FIFO文件，借助文件系统）：有名管道也是半双工的通信方式，但是允许在没有亲缘关系的进程之间使用，先进先出。</li>
<li>实现原理：在内核中开辟一块缓冲区用于通信。管道本质是一种文件。</li>
</ul>
</li>
<li>共享内存：映射一段能被其它进程访问的内存。往往与信号量配合使用来实现进程的同步和通信。</li>
<li>消息队列：消息队列是有消息的链表，存放在内核中，并由消息队列标识符标识。消息队列克服了信号传递少、管道只能承载无格式字符流以及缓冲区大小等缺点。</li>
<li>套接字：适用于不同机器间进程通信，在本地也可作为两个进程通信的方式。</li>
<li>信号：用于通知接收进程某个事件已经发生，比如按下ctrl + C就是信号。</li>
<li>信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，实现进程、线程的对临界区的同步及互斥访问。</li>
</ul>
<h3 id="3、系统中具有快表后，地址的转换过程变成什么样了？"><a href="#3、系统中具有快表后，地址的转换过程变成什么样了？" class="headerlink" title="3、系统中具有快表后，地址的转换过程变成什么样了？"></a>3、系统中具有快表后，地址的转换过程变成什么样了？</h3><p>① CPU给出逻辑地址，由某个硬件算得页号、页内偏移量，将页号与快表中的所有页号进行比较。</p>
<p>② 如果找到匹配的页号，说明要访问的页表项在快表中有副本，则直接从中取出该页对应的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此，若快表命中，则访问某个逻辑地址仅需一次访存。</p>
<p>③ 如果没有找到匹配的页号，则需要访问内存中的页表，找到对应页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。</p>
<p>​    若快表未命中，则需要两次访存。</p>
<h3 id="4、内存交换和覆盖有什么区别？"><a href="#4、内存交换和覆盖有什么区别？" class="headerlink" title="4、内存交换和覆盖有什么区别？"></a>4、内存交换和覆盖有什么区别？</h3><p>交换技术主要是在不同进程（或作业）之间进行，而覆盖则用于同一程序或进程中。</p>
<h3 id="5、动态分区算法有哪几种？"><a href="#5、动态分区算法有哪几种？" class="headerlink" title="5、动态分区算法有哪几种？"></a>5、动态分区算法有哪几种？</h3><p>1、首次适应算法</p>
<p>算法思想：每次都从低地址开始查找，找到第一个能满足大小的空闲分区。</p>
<p>2、最佳适应算法</p>
<p>算法思想：优先使用更小的空闲区，尽可能多地留下大片的空闲区。</p>
<p>3、最坏适应算法</p>
<p>算法思想：每次分配时优先使用最大的连续空闲区。</p>
<p>4、邻近适应算法</p>
<p>算法思想：每次都从上次查找结束的位置开始检索。</p>
<h3 id="6、进程状态的切换-进程的生命周期"><a href="#6、进程状态的切换-进程的生命周期" class="headerlink" title="6、进程状态的切换/进程的生命周期"></a>6、进程状态的切换/进程的生命周期</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">1[就绪态]</span><br><span class="line">2[运行态]</span><br><span class="line">3[阻塞态]</span><br><span class="line">4[创建态]</span><br><span class="line">5[终止态]</span><br><span class="line">4--创建--&gt;1</span><br><span class="line">1--调度--&gt;2</span><br><span class="line">2--I&#x2F;O或者等待事件--&gt;3</span><br><span class="line">3--I&#x2F;O或者事件完成--&gt;1</span><br><span class="line">2--打断--&gt;1</span><br><span class="line">2--退出--&gt;5</span><br></pre></td></tr></table></figure>

<ul>
<li>创建状态（created）：需要获取系统资源创建进程管理块（PCB：Process Control Block）完成资源分配。</li>
<li>就绪状态（ready）：等待被调度。在创建状态完成后，已经准备好，但还没获得处理器资源无法运行。</li>
<li>运行状态（running）：获取处理器资源，被系统调度。</li>
<li>阻塞状态（waiting）：在运行状态过程中，如果进行了阻塞的操作，如耗时的I/O操作，导致该进程暂时无法操作就进入阻塞状态。在这些操作完成后进入就绪状态再次等待获取处理器资源。</li>
<li>终止状态（dead）：进程结束或者被系统终止。</li>
</ul>
<h3 id="7、程序从开始到结束的完整过程"><a href="#7、程序从开始到结束的完整过程" class="headerlink" title="7、程序从开始到结束的完整过程"></a>7、程序从开始到结束的完整过程</h3><p>（1）<strong>预编译：</strong>处理源代码文件中以“#”开头的预编译指令。包括删除#define展开宏定义，处理预编译指令，删除注释等。</p>
<p>（2）<strong>编译：</strong>进行词法分析、语法分析、语义分析和优化后，生成汇编代码文件。</p>
<p>（3）<strong>汇编：</strong>将汇编代码转变为机器可以执行的指令（机器码文件）。</p>
<p>（4）<strong>链接：</strong>将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。链接分为静态链接和动态链接。</p>
<h3 id="8、虚拟内存的目的是什么？"><a href="#8、虚拟内存的目的是什么？" class="headerlink" title="8、虚拟内存的目的是什么？"></a>8、虚拟内存的目的是什么？</h3><p>虚拟内存是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。</p>
<p>为了更好地管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，被分成多个页。页被映射到物理内存中，但不需要映射到连续的物理内存，也不需要所有页都在物理内存中。</p>
<p>例如有一台计算机可以产生16位地址，那么一个程序的地址空间范围是0~64K。该计算机只有32KB的物理内存，虚拟内存技术允许该计算机运行一个64K大小的程序。</p>
<h3 id="9、死锁产生的原因"><a href="#9、死锁产生的原因" class="headerlink" title="9、死锁产生的原因"></a>9、死锁产生的原因</h3><p>四个必要条件，缺一不可。</p>
<p>1、<strong>互斥条件</strong>：进程对所需求的资源具有排他性，若有其他进程请求该资源，请求进程只能等待。</p>
<p>2、<strong>非抢占条件</strong>：进程在所获得的资源未释放前，不能被其他进程强行夺走，只能自己释放。</p>
<p>3、<strong>请求和保持条件</strong>：进程当前所拥有的资源在请求其他新资源时，由该进程继续占有。</p>
<p>4、<strong>循环等待条件</strong>：存在一种进程资源循环等待链，链中每个进程已获得的资源同时被链中下一个进程所请求。</p>
<p>解决死锁的对策：</p>
<ol>
<li><p>完全不管。</p>
</li>
<li><p>银行家算法，死锁避免</p>
</li>
<li><p>在检测到死锁之后剥夺资源</p>
</li>
</ol>
<h3 id="10、线程通信-同步的方式有哪些？"><a href="#10、线程通信-同步的方式有哪些？" class="headerlink" title="10、线程通信/同步的方式有哪些？"></a>10、线程通信/同步的方式有哪些？</h3><p>包括读写锁、信号量、条件变量、互斥量、临界区。</p>
<ul>
<li>临界区：每个线程中访问临界资源的代码片段。必须互斥地访问。</li>
<li>互斥量：只有拥有互斥对象的线程才可以访问。也称互斥锁。其实就是一个bool变量。</li>
<li>信号量：计数器，允许多个线程同时访问同一个资源。有P(sv)操作和V(sv)操作。</li>
<li>条件变量：通过条件变量通知操作的方式来保持多线程同步。</li>
<li>读写锁：与互斥量类似，互斥量要么是加锁、要么是不加锁。读写锁一次只允许一个线程写，但允许一次多个进程读。</li>
</ul>
<h3 id="11、Linux的fork的作用"><a href="#11、Linux的fork的作用" class="headerlink" title="11、Linux的fork的作用"></a>11、Linux的fork的作用</h3><p>fork函数用来创建一个子进程。对于父进程，fork()函数返回新创建的子进程的PID。对于子进程，fork()函数调用成功会返回0。如果创建出错，fork()函数返回-1.</p>
<h3 id="12、什么是孤儿进程、什么是僵尸进程，如何解决僵尸进程"><a href="#12、什么是孤儿进程、什么是僵尸进程，如何解决僵尸进程" class="headerlink" title="12、什么是孤儿进程、什么是僵尸进程，如何解决僵尸进程"></a>12、什么是孤儿进程、什么是僵尸进程，如何解决僵尸进程</h3><ul>
<li>孤儿进程：是指一个父进程退出后，它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。</li>
<li>是指一个进程使用fork函数创建子进程，如果子进程退出，而父进程没有调用wait()或waitpid()系统调用取得子进程的终止状态，那么子进程的进程描述符仍然保存在系统中，占用系统资源，这种进程称为僵尸进程。</li>
</ul>
<p>如何解决僵尸进程：</p>
<p>​    在fork子进程之后即时使用wait系统调用；</p>
<p>​    使用kill命令。</p>
<h3 id="13、内核态和用户态"><a href="#13、内核态和用户态" class="headerlink" title="13、内核态和用户态"></a>13、内核态和用户态</h3><p>用户态和内核态的区别：</p>
<p>（1）用户态和内核态是操作系统的两种运行级别。大部分用户直接面对的程序都运行在用户态上。当程序运行在0级特权级时，可以称之为运行在内核态。</p>
<p>（2）运行在用户态的程序不能直接访问操作系统内核。</p>
<p>（3）处于用户态运行时，进程所能访问的内存空间和对象受到限制，占有的处理机可以被抢占。</p>
<p>​          处于核心态运行中的进程，可以访问所有的内存空间和对象，所占有的处理机不允许被抢占。</p>
<p>导致用户态到内核态的切换：</p>
<p>（1）系统调用（主动）</p>
<p>（2）异常（被动）</p>
<p>（3）外围设备的中断（被动）</p>
<h3 id="14、进程调度算法有哪些？"><a href="#14、进程调度算法有哪些？" class="headerlink" title="14、进程调度算法有哪些？"></a>14、进程调度算法有哪些？</h3><ol>
<li><p>先来先服务调度算法</p>
</li>
<li><p>短作业优先调度算法</p>
</li>
<li><p>高优先级优先调度算法</p>
</li>
<li><p>时间片轮转法</p>
</li>
<li><p>多级队列反馈/多级队列调度</p>
<p>有抢占式和非抢占式的区别。</p>
</li>
</ol>
<h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h3 id="1、OSI的七层模型分别是？各自的功能是什么？TCP-IP四层模型是什么？"><a href="#1、OSI的七层模型分别是？各自的功能是什么？TCP-IP四层模型是什么？" class="headerlink" title="1、OSI的七层模型分别是？各自的功能是什么？TCP/IP四层模型是什么？"></a>1、OSI的七层模型分别是？各自的功能是什么？TCP/IP四层模型是什么？</h3><p><strong>OSI七层模型</strong></p>
<ul>
<li><strong>应用层</strong>：各种应用软件，包括Web应用。</li>
<li><strong>表示层</strong>：数据格式标识，基本压缩加密功能。</li>
<li><strong>会话层</strong>：控制应用程序之间会话能力，如不同软件数据分发给不同软件。</li>
<li><strong>传输层</strong>：端到端传输数据的基本功能，如TCP、UDP。传输层数据称为<strong>段</strong>（Segments）</li>
<li><strong>网络层</strong>：定义IP编址，定义路由功能，如不同设备的数据转发。网络层数据称为<strong>包</strong>（Packages）</li>
<li><strong>数据链路层</strong>：定义数据的基本格式，如何传输，如何标识，如网卡MAC地址。数据链路层数据称为<strong>帧</strong>（Frames）</li>
<li><strong>物理层</strong>：底层数据传输，如网线，网卡标准。数据称为比特流（Bits）</li>
</ul>
<p><strong>TCP/IP五层模型</strong></p>
<ul>
<li><strong>应用层</strong>：对应OSI参考模型的应用、表示、会话层。处理应用程序的逻辑。DNS协议。</li>
<li><strong>传输层</strong>：为两台主机上的应用程序提供端到端的通信。TCP协议，UDP协议。</li>
<li><strong>网络层</strong>：实现数据包的选路和转发。核心的协议是IP协议（因特网协议），ICMP协议（因特网控制报文协议）。</li>
<li><strong>数据链路层</strong>：实现了网卡接口的网络驱动程序，处理数据在物理媒介上的传输。</li>
<li><strong>物理层</strong>（如果是四层就没有这一层）</li>
</ul>
<p>分层的好处：独立，灵活，低耦合，让每一层专注其功能，减少各层的依赖。</p>
<h3 id="2、说一下一次完整的HTTP请求过程包括哪些内容？"><a href="#2、说一下一次完整的HTTP请求过程包括哪些内容？" class="headerlink" title="2、说一下一次完整的HTTP请求过程包括哪些内容？"></a>2、说一下一次完整的HTTP请求过程包括哪些内容？</h3><ul>
<li><p>建立起客户机和服务器连接。</p>
</li>
<li><p>建立连接后，客户机发送一个请求给服务器。</p>
</li>
<li><p>服务器收到请求给予响应信息。</p>
</li>
<li><p>客户端浏览器将返回的内容解析并呈现，断开连接。</p>
<p>HTTP请求方法有：GET、HEAD、POST、PUT、DELETE等</p>
</li>
</ul>
<h3 id="3、-在浏览器中输入URL地址后显示主页的过程？"><a href="#3、-在浏览器中输入URL地址后显示主页的过程？" class="headerlink" title="3、 在浏览器中输入URL地址后显示主页的过程？"></a>3、 在浏览器中输入URL地址后显示主页的过程？</h3><ul>
<li>根据域名，进行DNS域名解析。</li>
<li>拿到解析的IP地址，建立TCP连接。</li>
<li>向IP地址，发送HTTP请求。</li>
<li>服务器处理请求。</li>
<li>返回响应结果。</li>
<li>关闭TCP连接。</li>
<li>浏览器渲染HTML；</li>
<li>浏览器布局渲染。</li>
</ul>
<h3 id="4、HTTPS和HTTP的区别"><a href="#4、HTTPS和HTTP的区别" class="headerlink" title="4、HTTPS和HTTP的区别"></a>4、HTTPS和HTTP的区别</h3><p>1、HTTP协议是超文本传输协议，传输的数据都是未加密的明文数据，因此HTTP比较不安全。</p>
<p>​    HTTPS是由HTTP+SSL协议构建的可进行加密传输、身份认证的网络协议，更安全。</p>
<p>​    SSL代表安全套接字层，是用于加密和验证应用程序和Web服务器之间发送的数据的协议。非对称加密，公钥公开。</p>
<p>2、HTTPS协议需要申请证书，需要一定费用。</p>
<p>3、HTTPS的端口是443，HTTP的端口是80.二者使用的连接方式不一样。</p>
<h3 id="5、简述TCP和UDP的区别"><a href="#5、简述TCP和UDP的区别" class="headerlink" title="5、简述TCP和UDP的区别"></a>5、简述TCP和UDP的区别</h3><p>1、TCP协议是有连接的，在数据开始传送之前需要通过三次握手建立连接，会话结束之后要结束连接。UDP是无连接的。</p>
<p>2、TCP协议保证数据按序发送，按序到达，提供超时重传来保证可靠性；UDP不保证可靠性。</p>
<p>3、TCP头部需要20字节，UDP只需要8个字节。TCP速度慢，UDP速度快。TCP发送是重量级，UDP发送是轻量级。</p>
<p>4、TCP有拥塞控制和流量控制，UDP没有，网络拥堵不影响发送效率。</p>
<p>5、TCP是一对一的连接，UDP支持一对一，多对多，一对多的通信。</p>
<p>6、TCP面向的是字节流的服务，UDP面向的是报文的服务。TCP不保存数据边界，UDP保证。</p>
<p>7、TCP适用于金融领域等，UDP使用在游戏和娱乐场所。</p>
<p>基于TCP协议的：Telnet，FTP和SMTP；</p>
<p>基于UDP协议的：DHCP，DNS，SNMP，TFTP，BOOTP；</p>
<h3 id="6、三次握手、四次挥手（TCP连接和关闭的具体步骤）"><a href="#6、三次握手、四次挥手（TCP连接和关闭的具体步骤）" class="headerlink" title="6、三次握手、四次挥手（TCP连接和关闭的具体步骤）"></a>6、三次握手、四次挥手（TCP连接和关闭的具体步骤）</h3><p>三次握手的目的：连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，并交换TCP窗口大小信息。</p>
<p><strong>三次握手建立连接：</strong></p>
<p>（1）第一次握手：建立连接时，客户端向服务器发送SYN包（seq=x），请求建立连接，等待确认。</p>
<p>（2）第二次握手：服务端收到客户端的SYN包，回一个ACK包（ACK=x+1）确认收到，同时发送一个SYN包（seq=y）给客户端。</p>
<p>（3）第三次握手：客户端收到SYN+ACK包，再回一个ACK（ACK=y+1）告诉服务端已经收到。</p>
<p>（4）三次握手完成，成功建立连接，开始传输数据。</p>
<p><strong>四次挥手关闭连接：</strong></p>
<p>（1）客户端发送FIN包给服务端，告诉它自己的数据已经发送完毕，请求终止连接。此时客户端不发送数据，但还能接收数据。</p>
<p>（2）服务端收到FIN包，回一个ACK包给客户端告诉它已经收到包了。此时没有断开socket连接，而是等待剩下的数据传输完毕。</p>
<p>（3）服务端等待数据传输完毕后，向客户端发送FIN包，表示可以断开连接。</p>
<p>（4）客户端收到后，回一个ACK包表示确认收到。等待一段时间确保服务端不再发送数据过来然后彻底断开连接。</p>
<p>（服务端）close wait: 客户端不发送数据，服务端仍然接收数据，直到服务端发送关闭请求（半双工状态）</p>
<p>（客户端）time wait: 等待2倍的最长报文段寿命的时间，以接收服务端最后的报文</p>
<p><strong>为什么要四次挥手</strong></p>
<p>因为客户端想断开连接的时候，服务端可能还有消息传，如果改成三次，客户端可能会因为迟迟等不到确认而再次发送关闭请求。</p>
<p><strong>三次握手每次握手信息没收到怎么办：</strong></p>
<p>（1）第一次握手消息丢失，第二次握手消息丢失，都收不到ACK消息，会超时重传。</p>
<p>（2）第三次握手消息丢失，Server端在TCP连接的状态为SYN_RECV，并且会根据TCP的超时重传机制，等待3秒，6秒，12秒后重新发送SYN+ACK包。</p>
<p><strong>状态转移</strong></p>
<p><strong>三次握手</strong></p>
<ol>
<li>CLOSED：起始点，在超时或者链接关闭时候进入此状态，并不是一个真正的状态，而是这个状态图的假想起点和终点。</li>
<li>LISTEN：服务端等待连接的状态。服务器经过socket，bind，listen函数之后进入此状态，开始监听客户端发过来的连接请求。</li>
<li>SYN_SENT：第一次握手发生阶段，客户端发起连接。客户端调用connect，发送SYN给服务端，然后进入SYN_SENT状态，等待服务端确认。如果服务端不能连接，进入CLOSED状态。</li>
<li>SYN_RCVD：第二次握手发生阶段，跟 3 对应，这里是服务端收到了客户端的SYN，此时服务器由LISTEN进入SYN_RCVD状态，同时服务端回应一个ACK，再发送一个SYN即SYN+ACK给客户端。</li>
<li>ESTABLISTHED：第三次握手发生阶段，客户端收到服务端的ACK包之后，也会发送一个ACK确认包。客户端进入ESTABLISTHED状态，表示客户端这边已经准备好。服务端接收到客户端的ACK之后会从SYN_RCVD状态转移到ESTABLISHED状态，表明服务端也准备好进行数据传输了。</li>
</ol>
<p><strong>四次挥手</strong></p>
<ol>
<li><p>FIN_WAIT_1：第一次挥手。主动关闭的一方（可以是客户端也可以是服务端）终止连接时发送FIN给对方，然后等待对方返回ACK。调用close()，第一次挥手就进入此状态。</p>
</li>
<li><p>CLOSE_WAIT：接收到FIN之后，被动关闭的一方进入此状态。</p>
</li>
<li><p>FIN_WAIT_2：主动端先执行主动关闭发送FIN，然后接收到被动方返回的ACK后进入此状态。</p>
</li>
<li><p>LAST_ACK：被动方发起关闭请求，由状态2进入此状态。</p>
</li>
<li><p>CLOSING：两边同时发起关闭请求时（即主动方发送FIN，等待被动方返回ACK；同时被动方也发送了FIN，主动方接收到FIN之后发送ACK给被动方）。主动方会由FIN_WAIT_1进入此状态，然后等待被动方返回ACK。</p>
</li>
<li><p>TIME_WAIT：经过这个状态进入CLOSED状态。</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">graph </span><br><span class="line">CLOSED(CLOSED)</span><br><span class="line">LISTEN(LISTEN)</span><br><span class="line">SYN_RCVD(SYN_RCVD)</span><br><span class="line">SYN_SENT(SYN_SENT)</span><br><span class="line">ESTABLISTHED(ESTABLISTHED)</span><br><span class="line">CLOSE_WAIT(CLOSE_WAIT)</span><br><span class="line">LAST_ACK(LAST_ACK)</span><br><span class="line">FIN_WAIT_1(FIN_WAIT_1)</span><br><span class="line">CLOSING(CLOSING)</span><br><span class="line">FIN_WAIT_2(FIN_WAIT_2)</span><br><span class="line">TIME_WAIT(TIME_WAIT)</span><br><span class="line">CLOSED-.被动打开.-&gt;LISTEN</span><br><span class="line">LISTEN-.收到SYN,发送SYN,ACK.-&gt;SYN_RCVD</span><br><span class="line">SYN_RCVD-.收到ACK.-&gt;ESTABLISTHED</span><br><span class="line">ESTABLISTHED-.收到FIN,发送ACK.-&gt;CLOSE_WAIT</span><br><span class="line">CLOSE_WAIT-.关闭发送FIN.-&gt;LAST_ACK</span><br><span class="line">LISTEN--关闭--&gt;CLOSED</span><br><span class="line">SYN_RCVD--收到RST--&gt;LISTEN</span><br><span class="line">SYN_SENT--收到SYN,发送SYN,ACK同时打开--&gt;SYN_RCVD</span><br><span class="line">LISTEN--发送SYN--&gt;SYN_SENT</span><br><span class="line">CLOSED&#x3D;&#x3D;主动打开,发送SYN&#x3D;&#x3D;&gt;SYN_SENT</span><br><span class="line">SYN_SENT&#x3D;&#x3D;&gt;ESTABLISTHED</span><br><span class="line">ESTABLISTHED&#x3D;&#x3D;关闭,发送FIN&#x3D;&#x3D;&gt;FIN_WAIT_1</span><br><span class="line">SYN_RCVD--关闭发送ACK--&gt;FIN_WAIT_1</span><br><span class="line">FIN_WAIT_1--收到FIN,发送ACK--&gt;CLOSING</span><br><span class="line">CLOSING--收到ACK--&gt;TIME_WAIT</span><br><span class="line">FIN_WAIT_1--收到FIN,ACK,发送ACK--&gt;TIME_WAIT</span><br><span class="line">FIN_WAIT_1&#x3D;&#x3D;收到ACK&#x3D;&#x3D;&gt;FIN_WAIT_2</span><br><span class="line">FIN_WAIT_2&#x3D;&#x3D;收到FIN,发送ACK&#x3D;&#x3D;&gt;TIME_WAIT</span><br><span class="line">TIME_WAIT&#x3D;&#x3D;定时经过两倍报文段长度后&#x3D;&#x3D;&gt;CLOSED</span><br><span class="line">SYN_SENT--关闭或超时--&gt;CLOSED</span><br></pre></td></tr></table></figure>





<h3 id="7、MAC地址和IP地址"><a href="#7、MAC地址和IP地址" class="headerlink" title="7、MAC地址和IP地址"></a>7、MAC地址和IP地址</h3><p>（1）IP地址是逻辑地址，MAC地址是物理地址。MAC地址定义网络设备的位置。</p>
<p>（2）IP地址分配根据的是网络的拓扑结构。</p>
<p>（3）计算机之间的通信最终都表现为将数据包从某种形式的链路上的初始节点出发，从一个节点传递到另一个节点，最终传送到目的节点。数据包在这些节点之间的移动都是由ARP负责将IP地址映射到MAC地址上来完成的。</p>
<h3 id="8、两次握手行不行"><a href="#8、两次握手行不行" class="headerlink" title="8、两次握手行不行"></a>8、两次握手行不行</h3><ul>
<li>不行。TCP协议的通信双方必须维护序列号来标识发送的数据包中哪些是对方已经收到的。</li>
<li>如果只是两次握手，只有连接发起方的序列号能被确认，另一方的序列号没办法被确认。</li>
</ul>
<h3 id="9、TCP如何保证有序-超时重传"><a href="#9、TCP如何保证有序-超时重传" class="headerlink" title="9、TCP如何保证有序/超时重传"></a>9、TCP如何保证有序/超时重传</h3><p>​    主机每次发送数据时，TCP给每个数据包分配一个序列号，并且在特定的时间内等待接收主机对分配的这个序列号进行确认。</p>
<p>​    如果发送主机在一个特定时间内没有收到接收主机的确认，发送主机就会重传这个数据。</p>
<p>​    接收主机利用序列号对接收的数据进行确认，以便检测对方发送的数据是否有丢失或者乱序。</p>
<p>​    接收主机将这些数据按正确的顺序重组成数据流并传递到高层进行处理。</p>
<h3 id="10、Cookie和Session的关系和区别"><a href="#10、Cookie和Session的关系和区别" class="headerlink" title="10、Cookie和Session的关系和区别"></a>10、Cookie和Session的关系和区别</h3><ul>
<li>Cookie和Session都是会话的一种方式。</li>
<li>Cookie数据存放在客户的浏览器上，Session存放在服务器上。</li>
<li>Cookie不是很安全，别人可以分析本地的Cookie进行Cookie欺骗，Session比较安全。</li>
<li>Session会在一定时间内保存在服务器上，当访问增多会占用服务器资源。</li>
<li>单个Cookie保存的数据不能超过4k，一个站点一般最多保存20个Cookie。</li>
</ul>
<h3 id="11、简述HTTPS的加密与认证的过程"><a href="#11、简述HTTPS的加密与认证的过程" class="headerlink" title="11、简述HTTPS的加密与认证的过程"></a>11、简述HTTPS的加密与认证的过程</h3><p><strong>加密</strong>：客户端在浏览器输入一个https网址，然后链接到服务器的443端口。采用https协议的服务器必须有一套数字证书（一套公钥和密钥）。</p>
<p>​    首先服务器将公钥传送到客户端，客户端解析证书验证成功，就会生成一个随机数（私钥），并用证书将该随机数加密后传回服务器。服务器对其进行解密后，获取这个随机值，然后将要传输的信息和私钥通过某种加密算法混合在一起传到客户端。客户端根据之前的私钥随机数来解密。</p>
<p><strong>认证</strong>：首先浏览器会从内置的证书列表中索引，找到服务器下发证书对应的机构。如果没有找到就会提示该证书不可信任。如果找到了就取出该机构颁发的公钥。</p>
<p>用机构的证书公钥解密得到证书的内容和证书签名，内容包括网站的网址、公钥、证书的有效期。浏览器先验证证书签名的合法性。</p>
<p>签名通过后，浏览器验证证书记录的网址和当前网址是否一致，不一致的话会提示用户。然后检查证书有效期，证书过期了也会提示用户。</p>
<p>都通过认证后，浏览器就可以安全使用证书中的网站公钥。</p>
<h3 id="12、TCP可靠性保证"><a href="#12、TCP可靠性保证" class="headerlink" title="12、TCP可靠性保证"></a>12、TCP可靠性保证</h3><p>TCP提供了检验和、序列号/确认应答、超时重传、最大消息长度、滑动窗口控制等方法实现了可靠性传输。</p>
<ul>
<li><p>检验和</p>
<ul>
<li>通过检验和可以检测数据是否有差错和异常。计算检验和的时候，会在TCP首部加上12字节的伪首部。</li>
</ul>
</li>
<li><p>序列号/确认应答</p>
<ul>
<li>发送端发送信息给接收端，接收端会回应一个包。如果接收到没有回应确认包（ACK包）就会重发。接收端的应答包发送端没有收到也会重发。</li>
</ul>
</li>
<li><p>超时重传</p>
<ul>
<li>发送出去的数据包到接受到确认包之间的时间，如果超过了就会被认为是丢包了需要重传。</li>
</ul>
</li>
<li><p>最大消息长度</p>
<ul>
<li>在建立TCP连接的时候，双方约定一个最大的长度作为发送的单位，理想情况下该长度的数据刚好不被网络层分块。</li>
</ul>
</li>
<li><p>滑动窗口控制</p>
<ul>
<li><p>滑动窗口协议是接收方通告发送方自己的窗口大小，从而控制发送方的发送速度。</p>
</li>
<li><p>窗口的大小就是在无需等待确认包的情况下，发送端还能发送的最大数据量。</p>
</li>
<li><p>滑动窗口过小就会导致需要不停地对数据进行确认。</p>
</li>
</ul>
</li>
<li><p>拥塞控制</p>
<ul>
<li>慢开始-&gt;拥塞避免 -&gt; 快重传/快恢复：一旦收到三个相同的冗余ACK，就知道传输丢失，立刻重传丢失的分组, 阈值降为窗口的一半，重新开始拥塞避免阶段</li>
</ul>
</li>
</ul>
<pre><code>慢开始，拥塞窗口一开始指数增长，超过一定阈值后变线性增长，进入拥塞避免阶段。

遇到阻塞，会重新开始，且慢开始的阈值变成当前窗口的一半（快恢复）</code></pre><h3 id="13、网络编程"><a href="#13、网络编程" class="headerlink" title="13、网络编程"></a>13、网络编程</h3><p>网络变成对信息的发送接收，通过操作相应API调度计算机资源硬件，并且利用管道（网线）进行数据交互的过程。</p>
<p>套接字、数据包、网络模型。</p>
<p>Socket：简单来说是ip地址与端口的结合协议。一种地址与端口的结合描述协议。是网络API的集合实现。</p>
<p>Socket的组成与作用：在网络传输中用于唯一标识两个端点的链接。端点包括（ip+port）。</p>
<h3 id="14、HTTP状态码"><a href="#14、HTTP状态码" class="headerlink" title="14、HTTP状态码"></a>14、HTTP状态码</h3><ul>
<li><p>1XX：信息类状态码（表示接受请求状态处理）</p>
</li>
<li><p>2XX：成功状态码（表示请求正常处理完毕）</p>
</li>
<li><p>3XX：重定向（表示需要进行附加操作，已完成请求）</p>
<ul>
<li>301：跳转，代表永久性重定向（请求的资源已被分配了新的URL）</li>
<li>302：临时性重定向（请求的资源已经分配了新的URL，希望用户能使用新的URL来进行访问。）</li>
</ul>
</li>
<li><p>4XX：客户端错误（表示服务器无法处理请求）</p>
<ul>
<li>404：服务器上无法找到请求的资源</li>
</ul>
</li>
<li><p>5XX：服务器错误状态码（表示服务器处理请求的时候出错）</p>
</li>
</ul>
<h3 id="15、HTTP-1-0-1-1-2-0的主要区别"><a href="#15、HTTP-1-0-1-1-2-0的主要区别" class="headerlink" title="15、HTTP 1.0,1.1,2.0的主要区别"></a>15、HTTP 1.0,1.1,2.0的主要区别</h3><p>http/1.0：</p>
<ul>
<li>默认不支持长连接，需要设置 keep-alive 参数指定</li>
<li>强缓存expired，协商缓存 last-modified\if-modified-since 有一定缺陷。</li>
</ul>
<p>http/1.1：</p>
<ul>
<li>默认长连接（keep-alive），http请求可以复用TCP连接，但是同一时间只能对应一个http请求。</li>
<li>增加了强缓存cache-control，协商缓存etag\if-none-match 是对http/1.0 缓存的优化</li>
</ul>
<p>http/2.0：</p>
<ul>
<li>多路复用，一个TCP中多个http请求是并行的。</li>
<li>二进制格式编码传输。</li>
<li>服务端推送。</li>
<li>使用HPACK算法做header压缩。</li>
</ul>
<h3 id="16、说说GET请求和POST请求的区别"><a href="#16、说说GET请求和POST请求的区别" class="headerlink" title="16、说说GET请求和POST请求的区别"></a>16、说说GET请求和POST请求的区别</h3><p>（1）GET请求在URL中传送的参数是有长度限制的，而POST没有。</p>
<p>（2）GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</p>
<p>（3）GET参数通过URL传递，POST放在Request body中。</p>
<p>（4）GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</p>
<p>（5）GET请求只能进行URL编码，而POST支持多种编码方式。</p>
<p>（6）GET请求会被浏览器主动cache，而POST不会，除非手动设置。</p>
<p>（7）GET产生的URL地址可以被Bookmark，而POST不可以。</p>
<p>（8）GET在浏览器回退时是无害的，而POST会再次提交请求。</p>
<h3 id="17、对称加密和非对称加密"><a href="#17、对称加密和非对称加密" class="headerlink" title="17、对称加密和非对称加密"></a>17、对称加密和非对称加密</h3><p>对称加密：对称加密和解密使用同一个密钥。</p>
<p>非对称加密：使用不同的密钥。</p>
<p>安全性不同：对称加密有可能被窃听，非对称加密只有公钥公开，解密需要用私钥，更安全。</p>
<h2 id="数据库-MySQL"><a href="#数据库-MySQL" class="headerlink" title="数据库(MySQL)"></a>数据库(MySQL)</h2><h3 id="1、关系型和非关系型数据库的区别你了解多少？"><a href="#1、关系型和非关系型数据库的区别你了解多少？" class="headerlink" title="1、关系型和非关系型数据库的区别你了解多少？"></a>1、关系型和非关系型数据库的区别你了解多少？</h3><ul>
<li>关系型数据库的优点<ul>
<li>容易理解。采用关系模型来组织数据。</li>
<li>可以保持数据的一致<ul>
<li>·性。</li>
</ul>
</li>
<li>数据更新的开销比较小。</li>
<li>支持复杂查询（带where子句的查询）</li>
</ul>
</li>
<li>非关系型数据库的优点（NoSQL not only SQL）<ul>
<li>不需要经过SQL层的解析，读写效率高。</li>
<li>基于键值对，数据的拓展性很好。</li>
<li>可以支持多种类型数据的存储，如图片，文档等。</li>
</ul>
</li>
</ul>
<h3 id="2、数据库隔离级别"><a href="#2、数据库隔离级别" class="headerlink" title="2、数据库隔离级别"></a>2、数据库隔离级别</h3><ul>
<li><strong>读未提交</strong>，事务中发生了修改，即使没有提交，其他事务也可见。<strong>可能会导致脏读、幻读、不可重复读。</strong></li>
<li><strong>读已提交</strong>，一个事务从开始直到提交之前，所做的修改是其他事务不可见的。执行两次SQL语句可能导致查询结果不同。<strong>可以阻止脏读，但是有可能会导致幻读或者不可重复读。</strong>这个是大多数数据库的隔离级别。</li>
<li><strong>可重复读</strong>，（MySQL InnoDB默认支持的隔离级别。但是使用了间隙锁算法，可以避免幻读。通过MVCC（多版本并发控制）来解决不可重复读。）对一个记录读取多次的结果是相同的。<strong>可以阻止脏读和不可重复读，有可能会导致幻读。</strong></li>
<li><strong>可串行化</strong>，在并发情况下和串行化读取结果一致。<strong>可以防止脏读、不可重复读和幻读。</strong></li>
<li>隔离级别越低，性能越高，越不安全。隔离级别越高，性能越差，越安全。</li>
</ul>
<h3 id="3、数据库并发事务会带来那些问题？"><a href="#3、数据库并发事务会带来那些问题？" class="headerlink" title="3、数据库并发事务会带来那些问题？"></a>3、数据库并发事务会带来那些问题？</h3><ul>
<li><strong>脏读</strong>：读取到了其他事务未提交的数据。在第一个修改事务和读取事务进行的时候，修改某一值，但是第二个事务读取到该值时，前一个事务因为某种原因比如事务一致性撤销了对该值的修改。</li>
<li><strong>不可重复读</strong>：前后多次读取，数据内容不一致。在一个事务内，最开始读到的数据和事务结束前的任意时刻读到的同一批数据出现不一致的情况。</li>
<li><strong>幻读</strong>：前后多次读取，数据总量不一致。T1在某个范围内进行新增或删除，T2读取该范围导致读到的数据是修改之间的。<ul>
<li>解决幻读：串行化，可重复读+间隙锁</li>
</ul>
</li>
</ul>
<h3 id="4、MySQL索引主要使用的两种数据结构是什么？"><a href="#4、MySQL索引主要使用的两种数据结构是什么？" class="headerlink" title="4、MySQL索引主要使用的两种数据结构是什么？"></a>4、MySQL索引主要使用的两种数据结构是什么？</h3><ul>
<li>哈希索引，底层的数据结构是哈希表。</li>
<li>B+Tree索引。</li>
</ul>
<h3 id="5、事务的四大特性。"><a href="#5、事务的四大特性。" class="headerlink" title="5、事务的四大特性。"></a>5、事务的四大特性。</h3><p>ACID四大特性：</p>
<ul>
<li><strong>原子性</strong>：事务包含的所有操作要么全部成功，要么全部失败回滚。<ul>
<li>实现方式：利用Innodb的undo log（回滚日志），记录回滚需要的信息，当事务执行失败的时候，可以回滚到修改之前的样子。</li>
</ul>
</li>
<li><strong>一致性</strong>：事务开始前和结束后，数据库的完整性约束没有被破坏。<ul>
<li>通过其他三个特性来保证一致性。</li>
</ul>
</li>
<li><strong>隔离性</strong>：多个并发事务相互隔离，每个事务不被其他事务的操作所干扰。<ul>
<li>通过锁机制或者MVCC来实现隔离性。</li>
</ul>
</li>
<li><strong>持久性</strong>：事务一旦被提交了，对数据的改变是永久性的。<ul>
<li>利用Innodb的redo log（重写日志）。当做数据修改的时候，不仅在内存中操作，还会在redo log中记录这次操作。当数据库宕机重启的时候，会将redo log中的内容恢复到数据库中。</li>
<li>刷盘效率比数据页刷盘高。redo log是顺序IO。</li>
</ul>
</li>
</ul>
<h3 id="6、数据库设计的范式"><a href="#6、数据库设计的范式" class="headerlink" title="6、数据库设计的范式"></a>6、数据库设计的范式</h3><p>关系数据库有六种范式，一般来说，数据库满足第三范式（3NF）就足够了。</p>
<ul>
<li>第一范式（1NF）：是指在关系模型中，对于添加的一个规范要求，所有的域都应该是原子性的。即数据库表的每一列都是不可分割的原子数据项，而不能是集合、数组、记录等非原子数据项。即实体中的某个属性有多个值时，必须拆分为不同的属性。<strong>属性不能再分割。</strong></li>
<li>第二范式（2NF）：在1NF的基础上，非码属性必须完全依赖于候选码。（<strong>消除非主属性对主码的部分函数依赖</strong>）。</li>
<li>第三范式（3NF）：在2NF基础上，任何非主属性不依赖于其他非主属性。（在2NF基础上<strong>消除非主属性对码的传递依赖</strong>）。</li>
<li>BCNF：消除主属性对码的部分和传递函数依赖。</li>
</ul>
<h3 id="7、说说你对redo-log、undo-log、binlog的了解"><a href="#7、说说你对redo-log、undo-log、binlog的了解" class="headerlink" title="7、说说你对redo log、undo log、binlog的了解"></a>7、说说你对redo log、undo log、binlog的了解</h3><ul>
<li>binlog（Binary Log）：<ul>
<li>二进制日志文件就是常说的binlog。记录了MySQL所有修改数据库的操作，还包括每条语句所执行的时间和所消耗的资源。</li>
</ul>
</li>
<li>redo log：<ul>
<li>重写日志，用来实现事务的持久性。由两部分组成，一是内存中的重写日志缓冲（redo log buffer），易失；二是重写日志文件（redo log file），是持久的。redo log基本是顺序写的。</li>
<li>当事务提交时，必须将该事务的日志写入到重做日志（redo log+undo log）文件中进行持久化，该事务的COMMIT操作才算完成。</li>
</ul>
</li>
<li>undo log：<ul>
<li>redo log进行重做，undo log进行回滚。undo log是需要进行随机读写的。undo log存放在数据库内部的一个特殊段（segment）中，称为undo 段。</li>
</ul>
</li>
<li>relay log</li>
</ul>
<h3 id="8、谈谈你对MVCC的了解。"><a href="#8、谈谈你对MVCC的了解。" class="headerlink" title="8、谈谈你对MVCC的了解。"></a>8、谈谈你对MVCC的了解。</h3><p>​    MVCC全程Multi-Version-Concurrency Control，多版本的并发控制协议。最大的优点是读不加锁，读写不冲突，并发性能好。</p>
<p>​    InnoDB实现MVCC，主要基于以下技术和数据结构：</p>
<ul>
<li>隐藏列，包含本行事务的事务id，指向undo log的指针。</li>
<li>基于undo log的版本链：每行数据的隐藏列中包含了指向undo log的指针，而undo log也会指向更早版本的undo log，形成一条版本链。</li>
<li>ReadView：通过隐藏列和版本链，MySQL可以将数据恢复到指定版本。但是具体要恢复到哪个版本，需要根据ReadView来确定。</li>
</ul>
<h3 id="9、MySQL主从同步是如何实现的？"><a href="#9、MySQL主从同步是如何实现的？" class="headerlink" title="9、MySQL主从同步是如何实现的？"></a>9、MySQL主从同步是如何实现的？</h3><p>分为以下三个步骤：</p>
<p>（1）主服务器，把数据更改记录到二进制日志（binlog）中。</p>
<p>（2）从服务器，把主服务器的二进制日志复制到自己的中继日志（relay log）中。</p>
<p>（3）从服务器，重做中继日志中的日志，把更改应用到自己的数据库上，以达成数据的一致性。</p>
<p>​    复制是异步实时。</p>
<h3 id="10、你知道哪些数据库结构优化的手段？"><a href="#10、你知道哪些数据库结构优化的手段？" class="headerlink" title="10、你知道哪些数据库结构优化的手段？"></a>10、你知道哪些数据库结构优化的手段？</h3><ul>
<li>范式优化：消除冗余。</li>
<li>反范式优化：适当加冗余（减少join）</li>
<li>限定数据的范围：禁止不带任何限制数据范围的查询语句。</li>
<li>读/写分离：经典的数据库拆分方案，主库负责写，从库负责读。</li>
<li>拆分表：分为垂直拆分和水平拆分。分区将数据在物理上分隔开来。</li>
<li>建立索引</li>
</ul>
<h3 id="11、锁"><a href="#11、锁" class="headerlink" title="11、锁"></a>11、锁</h3><p>innodb支持行级锁和表级锁</p>
<p>表级锁：对当前操作的整张表加锁，不会死锁，资源消耗小，并发低</p>
<p>行级锁：对当前操作的行加锁，会死锁，并发高，资源消耗大</p>
<p>算法：记录锁，间隙锁，临键锁</p>
<p>记录锁：只锁数据本身</p>
<p>间隙锁：锁一段区间，不锁记录本身</p>
<p>行级锁：共享锁（读锁），排他锁（写锁）</p>
<p>表级别锁：意向共享，意向排他</p>
<p>意向锁与自己和行锁之间不冲突</p>
<p>意向锁：就是，比如我上一个行 排他锁，就要也上一个意向排他锁，告诉表锁，我这个表里面有排他锁</p>
<p>解决表锁要整个遍历行锁的问题</p>
<p><strong>死锁</strong>：两个事务争抢资源导致相互等待</p>
<p>InnoDB减少死锁：</p>
<ul>
<li>自动死锁检测，优先回滚小事务。</li>
<li>超时设置</li>
<li>尽快提交事务，小事务不容易发生死锁</li>
<li>减少扫描/锁范围，降低概率</li>
</ul>
<p>乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据</p>
<p>悲观锁：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。</p>
<h3 id="12、索引"><a href="#12、索引" class="headerlink" title="12、索引"></a>12、索引</h3><p>是帮助MySQL高效获取数据的一种数据结构，存储在磁盘文件里。</p>
<p>数据结构：B树，B+树，hash</p>
<p>B+：叶子节点放数据，叶子有个指针，形成有序链表</p>
<p>B：内部节点也放数据</p>
<p>主键索引：以主键建立索引，innodb默认6byte的自增主键</p>
<p>辅助索引：叶子节点存主键，通过其他的字段去查主键</p>
<p>辅助索引的类别：</p>
<p>唯一索引：表示唯一的，不允许重复的字段。主键自动有唯一索引。</p>
<p>普通索引：数据允许重复</p>
<p>前缀索引：字符串</p>
<p>全文索引：检测大文本数据中的关键字。检索长文本效果较好。</p>
<p>如何添加索引：</p>
<ol>
<li>图形界面操作</li>
<li>通过SQL语句创建</li>
</ol>
<p>索引失效：最佳左前缀法则</p>
<p>索引失效主要针对联合索引。</p>
<p>最左有序，其他相对有序。</p>
<p>聚集索引：数据索引放一起（主键索引）</p>
<p>非聚集索引：数据索引分开存</p>
<p>覆盖索引：索引与值一样，无需回表</p>
<h3 id="13、B树、B-树、红黑树"><a href="#13、B树、B-树、红黑树" class="headerlink" title="13、B树、B+树、红黑树"></a>13、B树、B+树、红黑树</h3><p><strong>B+树是B树的一种变形形式</strong>，B+树的叶子结点存储关键字以及相应记录的地址，叶子结点以上作为索引使用。一棵m阶的B+树定义如下：</p>
<p>（1）每个结点至多有m个子女。</p>
<p>（2）除根结点外，每个结点至少有[m/2]个子女，根结点至少有两个子女。</p>
<p>（3）有k个子女的结点必有k个关键字。</p>
<p>当索引部分某个结点关键字与所查关键字相等时，并不停止查找，继续沿着这个关键字左边的指针向下，一直找到该关键字所在的叶子结点。</p>
<p><strong>为什么不能用二叉查找树：</strong></p>
<p>索引存在磁盘上，数据量比较大的时候，索引大小可能有很多G，没办法全部加载到内存，只能逐一加载磁盘页。需要减少高度。</p>
<p>B+树比B树的好处：</p>
<p>所有叶子结点形成有序链表，便于范围查询。</p>
<p>所有查询都需要查询到叶子结点，性能稳定。</p>
<p>单一结点存储更多的元素，树变得矮胖，查询IO次数更少。</p>
<p><strong>红黑树</strong>是一种自平衡二叉树，有以下性质：</p>
<p>（1）结点是红色或者黑色</p>
<p>（2）根节点是黑色</p>
<p>（3）所有叶子结点都是黑色</p>
<p>（4）每个红色结点的子结点都是黑色</p>
<p>（5）从任一结点到其每个结点的所有路径都包含相同数目的黑色结点</p>
<p>关键性质：从根到叶子的最长的可能路径不多于最短的可能路径的两倍。</p>
<h3 id="14、银行家算法"><a href="#14、银行家算法" class="headerlink" title="14、银行家算法"></a>14、银行家算法</h3><p>银行家算法是死锁避免算法。</p>
<p>在系统中设置四个数据结构，用来描述系统中可利用的资源，进程对资源的最大需求，系统中的资源分配，以及所有进程还需要多少资源的情况。</p>
<p>当一个进程申请使用资源的时候，银行家算法通常先试探分配给该进程的资源，然后通过安全性算法判断分配后的系统是否处于安全状态，若不安全则试探分配作废，让该进程继续等待。</p>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>c写的内存形数据库</p>
<p>作用：分布式缓存（能提高并发量），分布式锁，消息队列</p>
<p>基本数据结构：string list hash set sorted_set bitmap</p>
<p>redis如何保证持久化：快照（创建副本），追加文件（记录操作的指令）</p>
<p>缓存击穿：缓存没有，大量查找数据库（也没有）</p>
<p>解决：对于无效key写入缓存告诉无效，或者布隆过滤器</p>
<p>缓存雪崩：缓存失效，导致大量请求落在数据库上</p>
<p>解决：redis集群</p>
<p>如何保证数据库与缓存一致：</p>
<p>数据库更新触发缓存更新，缓存更新失败触发缓存更新重试机制</p>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="1、什么是单例设计模式，如何实现"><a href="#1、什么是单例设计模式，如何实现" class="headerlink" title="1、什么是单例设计模式，如何实现"></a>1、什么是单例设计模式，如何实现</h3><p>1、单例模式定义</p>
<p>​    保证一个类仅有一个实例，并提供一个访问它的全局访问点，该实例被所有程序模块共享。</p>
<p>​    保证：（1）该类不能被复制。（2）该类不能被公开的创造。</p>
<p>​    在C++中，它的构造函数，拷贝构造函数和复制函数都不能被公开调用。</p>
<p>2、单例模式实现方式</p>
<p>​    分为懒汉式单例和饿汉式单例。</p>
<p>​    懒汉模式：特点是延迟加载。比如配置文件。采取懒汉式的方法，配置文件的实例直到用到的时候才会加载，不到万不得已就不会去实例化类。</p>
<p>​        a. 静态指针 + 用到时初始化</p>
<p>​        b. 局部静态变量</p>
<p>​    饿汉模式：</p>
<p>​        a. 直接定义静态对象</p>
<p>​        b. 静态指针 + 类外初始化时new空间 实现 </p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">学习笔记</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B1%82%E8%81%8C/" rel="tag">求职</a></li></ul>


    </footer>

  </div>

  

  
  
  

  
  
  

</article>
    
  </article>
  

  
  <nav class="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2020-2023
        <i class="ri-heart-fill heart_icon"></i> Rye
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></s>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="STILL LIVING"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%97%85%E8%A1%8C/">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/photos">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2020/10/04/%E5%85%B3%E4%BA%8E%E6%88%91/">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>

<!-- Subtitle -->

<script>
  try {
    var typed = new Typed("#subtitle", {
      strings: ['在我们脚下，风在摸索船帆，而群星强烈地搏动。', '在告别的内部是悲剧。正如一切事情的内部，时间昭然可见', '若相遇是可以期待的，告别何以谓之告别。'],
      startDelay: 0,
      typeSpeed: 200,
      loop: true,
      backSpeed: 100,
      showCursor: true
    });
  } catch (err) {
    console.log(err)
  }
</script>

<!-- Tocbot -->

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<!-- ClickLove -->

<!-- CodeCopy -->


<link rel="stylesheet" href="/css/clipboard.css">

<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>



    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="52"
        src="//music.163.com/outchain/player?type=2&id=571339491&auto=1&height=32"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
  </div>
</body>

</html>